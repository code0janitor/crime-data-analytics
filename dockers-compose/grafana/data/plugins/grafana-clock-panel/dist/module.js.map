{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"moment\"","webpack:///./module.ts","webpack:///./clock_ctrl.ts","webpack:///./external/moment-duration-format.js","webpack:///./css/clock-panel.css?1151","webpack:///./css/clock-panel.css","webpack:///../node_modules/css-loader/lib/css-base.js","webpack:///../node_modules/style-loader/lib/addStyles.js","webpack:///../node_modules/style-loader/lib/urls.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","default","object","property","prototype","hasOwnProperty","p","s","e","__WEBPACK_EXTERNAL_MODULE__0__","_clock_ctrl","PanelCtrl","ClockCtrl","_sdk","a","setPrototypeOf","__proto__","Array","this","constructor","_super","$scope","$injector","_this","panelDefaults","clockType","offsetFromUtc","offsetFromUtcMinutes","bgColor","countdownSettings","endCountdownTime","_moment2","seconds","milliseconds","add","toDate","endText","customFormat","dateSettings","showDate","dateFormat","fontSize","fontWeight","timeSettings","refreshSettings","syncWithDashboard","defaultsDeep","panel","Date","__extends","$inject","onInitEditMode","addEditorTab","onPanelTeardown","$timeout","cancel","nextTickPromise","updateClock","renderTime","renderCountdown","offsetInMinutes","parseInt","now","utcOffset","date","format","time","getTimeFormat","timeLeft","asSeconds","years","formattedTimeLeft","previous","months","days","hours","minutes","link","scope","elem","events","on","find","$panelContainer","css","templateUrl","u","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","root","factory","moment","bubbles","type","targets","stringIncludes","str","search","length","indexOf","repeatZero","qty","result","formatNumber","number","options","userLocale","integerString","fractionString","useToLocaleString","useGrouping","grouping","slice","maximumSignificantDigits","minimumIntegerDigits","fractionDigits","groupingSeparator","localeStringOptions","maximumFractionDigits","minimumFractionDigits","toLocaleStringRoundingWorks","roundingOptions","extend","decimalSeparator","parseFloat","toLocaleString","toPrecision","toFixed","split","w","integerLength","fractionLength","digitCount","L","digits","digitsArray","reverse","carry","toString","push","join","replace","M","exponent","Math","abs","temp","group","shift","formattedString","durationLabelCompare","b","label","engLocale","durationLabelsStandard","S","SS","ss","mm","h","hh","dd","ww","MM","y","yy","durationLabelsShort","durationTimeTemplates","HMS","HM","MS","durationLabelTypes","string","durationPluralKey","token","integerValue","decimalValue","isArray","array","isObject","obj","callback","match","item","index","max","each","map","ret","pluck","prop","compact","unique","_a","intersection","_b","rest","keys","any","durationsFormat","settings","arguments","arg","durations","precision","template","returnMomentTypes","formattedDurations","dur","child","concat","largest","outputTypes","args","asMilliseconds","isValid","asMonths","_","remainder","duration","V","momentTokens","weeks","tokenDefs","escape","general","types","typeMap","test","tokenizer","RegExp","source","stopTrim","localeData","_durationTimeTemplates","useLeftUnits","usePlural","forceLength","useSignificantDigits","significantDigits","q","Y","minValue","maxValue","trim","trimIncludes","rBoth","rAll","trimLarge","trimSmall","trimMid","rawTokens","currentToken","text","pt","tokens","momentTypes","momentType","rawValue","remainderMonths","as","wholeValue","floor","isLargest","isMaxValue","isSmallest","isMinValue","subtract","tokenLength","truncMethod","trunc","round","truncate","places","factor","pow","foundFirst","yt","formatValue","formatOptions","bubbled","formattedValue","P","formattedValueEn","formattedValueMS","mt","g","findType","bubble","bubbleMomentType","target","targetMomentType","significantDigitsCache","trimFinal","outputType","values","E","localeDataKey","toLowerCase","labelKey","labels","labelType","_durationLabelTypes","pluralKey","autoLocalized","pluralizedLabels","out","isNegative","defaultFormatTemplate","_data","firstType","lastType","init","context","fn","defaults","updateLocale","toLocaleStringWorks","passed","featureTestToLocaleString","T","apply","momentDurationFormatSetup","transform","version","sources","names","mappings","file","sourcesContent","sourceRoot","useSourceMap","list","content","cssMapping","btoa","sourceMapping","sourceMap","unescape","encodeURIComponent","JSON","stringify","sourceURLs","mediaQuery","alreadyImportedModules","id","isOldIE","memo","window","document","all","atob","getElement","parent","styleTarget","querySelector","HTMLIFrameElement","contentDocument","head","singleton","singletonCounter","addStylesToDom","styles","domStyle","refs","j","parts","addStyle","stylesInDom","listToStyles","base","media","newStyles","part","insertStyleElement","style","Error","insertAt","lastStyleElementInsertedAtTop","nextSibling","insertBefore","appendChild","firstChild","stylesInsertedAtTop","before","removeStyleElement","parentNode","removeChild","idx","splice","createStyleElement","attrs","nonce","nc","addAttrs","el","forEach","setAttribute","update","applyToSingletonTag","styleIndex","v","URL","createObjectURL","revokeObjectURL","Blob","rel","convertToAbsoluteUrls","autoFixUrls","fixUrls","href","oldSrc","remove","styleSheet","cssText","createTextNode","newObj","DEBUG","insertInto","f","newList","mayRemove","replaceText","replacement","textStore","filter","Boolean","cssNode","childNodes","location","baseUrl","protocol","host","fullMatch","origUrl","unquotedOrigUrl","$1","newUrl","currentDir"],"mappings":"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","file":"module.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","import {ClockCtrl} from './clock_ctrl';\n\nexport {\n  ClockCtrl as PanelCtrl\n};\n","import { PanelCtrl } from 'grafana/app/plugins/sdk';\nimport moment from 'moment';\nimport './external/moment-duration-format';\nimport _ from 'lodash';\nimport './css/clock-panel.css';\n\nexport class ClockCtrl extends PanelCtrl {\n  static templateUrl = 'partials/module.html';\n\n  panelDefaults = {\n    mode: 'time',\n    clockType: '24 hour',\n    offsetFromUtc: null,\n    offsetFromUtcMinutes: null,\n    bgColor: null,\n    countdownSettings: {\n      endCountdownTime: moment()\n        .seconds(0)\n        .milliseconds(0)\n        .add(1, 'day')\n        .toDate(),\n      endText: '00:00:00',\n      customFormat: null,\n    },\n    dateSettings: {\n      showDate: false,\n      dateFormat: 'YYYY-MM-DD',\n      fontSize: '20px',\n      fontWeight: 'normal',\n    },\n    timeSettings: {\n      customFormat: 'HH:mm:ss',\n      fontSize: '60px',\n      fontWeight: 'normal',\n    },\n    refreshSettings: {\n      syncWithDashboard: false,\n    },\n  };\n  nextTickPromise: any;\n  date: string;\n  time: string;\n\n  /** @ngInject */\n  constructor($scope, $injector) {\n    super($scope, $injector);\n    _.defaultsDeep(this.panel, this.panelDefaults);\n\n    if (!(this.panel.countdownSettings.endCountdownTime instanceof Date)) {\n      this.panel.countdownSettings.endCountdownTime = moment(this.panel.countdownSettings.endCountdownTime).toDate();\n    }\n\n    this.events.on('init-edit-mode', this.onInitEditMode.bind(this));\n    this.events.on('panel-teardown', this.onPanelTeardown.bind(this));\n    this.events.on('panel-initialized', this.render.bind(this));\n    this.events.on('component-did-mount', this.render.bind(this));\n    this.events.on('refresh', this.updateClock.bind(this));\n    this.events.on('render', this.updateClock.bind(this));\n\n    this.updateClock();\n  }\n\n  onInitEditMode() {\n    this.addEditorTab('Options', 'public/plugins/grafana-clock-panel/partials/options.html', 2);\n    this.addEditorTab('Refresh', 'public/plugins/grafana-clock-panel/partials/refresh.html', 2);\n  }\n\n  onPanelTeardown() {\n    this.$timeout.cancel(this.nextTickPromise);\n  }\n\n  updateClock() {\n    this.$timeout.cancel(this.nextTickPromise);\n    if (this.panel.mode === 'time') {\n      this.renderTime();\n    } else {\n      this.renderCountdown();\n    }\n\n    if (!this.panel.refreshSettings.syncWithDashboard) {\n      this.nextTickPromise = this.$timeout(this.updateClock.bind(this), 1000);\n    }\n  }\n\n  renderTime() {\n    let now;\n\n    if (this.panel.offsetFromUtc && this.panel.offsetFromUtcMinutes) {\n      const offsetInMinutes =\n        parseInt(this.panel.offsetFromUtc, 10) * 60 + parseInt(this.panel.offsetFromUtcMinutes, 10);\n      now = moment().utcOffset(offsetInMinutes);\n    } else if (this.panel.offsetFromUtc && !this.panel.offsetFromUtcMinutes) {\n      now = moment().utcOffset(parseInt(this.panel.offsetFromUtc, 10));\n    } else {\n      now = moment();\n    }\n\n    if (this.panel.dateSettings.showDate) {\n      this.date = now.format(this.panel.dateSettings.dateFormat);\n    }\n\n    this.time = now.format(this.getTimeFormat());\n  }\n\n  getTimeFormat() {\n    if (this.panel.clockType === '24 hour') {\n      return 'HH:mm:ss';\n    }\n\n    if (this.panel.clockType === '12 hour') {\n      return 'h:mm:ss A';\n    }\n\n    return this.panel.timeSettings.customFormat;\n  }\n\n  renderCountdown() {\n    if (!this.panel.countdownSettings.endCountdownTime) {\n      this.time = this.panel.countdownSettings.endText;\n    }\n\n    const now = moment();\n    const timeLeft = moment.duration(moment(this.panel.countdownSettings.endCountdownTime).diff(now));\n    let formattedTimeLeft = '';\n\n    if (timeLeft.asSeconds() <= 0) {\n      this.time = this.panel.countdownSettings.endText;\n      return;\n    }\n\n    if (this.panel.countdownSettings.customFormat === 'auto') {\n      this.time = (timeLeft as any).format();\n      return;\n    }\n\n    if (this.panel.countdownSettings.customFormat) {\n      this.time = (timeLeft as any).format(this.panel.countdownSettings.customFormat);\n      return;\n    }\n\n    let previous = '';\n\n    if (timeLeft.years() > 0) {\n      formattedTimeLeft = timeLeft.years() === 1 ? '1 year, ' : timeLeft.years() + ' years, ';\n      previous = 'years';\n    }\n    if (timeLeft.months() > 0 || previous === 'years') {\n      formattedTimeLeft += timeLeft.months() === 1 ? '1 month, ' : timeLeft.months() + ' months, ';\n      previous = 'month';\n    }\n    if (timeLeft.days() > 0 || previous === 'months') {\n      formattedTimeLeft += timeLeft.days() === 1 ? '1 day, ' : timeLeft.days() + ' days, ';\n      previous = 'days';\n    }\n    if (timeLeft.hours() > 0 || previous === 'days') {\n      formattedTimeLeft += timeLeft.hours() === 1 ? '1 hour, ' : timeLeft.hours() + ' hours, ';\n      previous = 'hours';\n    }\n\n    if (timeLeft.minutes() > 0 || previous === 'hours') {\n      formattedTimeLeft += timeLeft.minutes() === 1 ? '1 minute, ' : timeLeft.minutes() + ' minutes, ';\n    }\n\n    formattedTimeLeft += timeLeft.seconds() === 1 ? '1 second ' : timeLeft.seconds() + ' seconds';\n    this.time = formattedTimeLeft;\n  }\n\n  link(scope, elem) {\n    this.events.on('render', () => {\n      const $panelContainer = elem.find('.panel-container');\n\n      if (this.panel.bgColor) {\n        $panelContainer.css('background-color', this.panel.bgColor);\n      } else {\n        $panelContainer.css('background-color', '');\n      }\n    });\n  }\n}\n","/*! Moment Duration Format v2.2.1\n *  https://github.com/jsmreese/moment-duration-format\n *  Date: 2018-01-21\n *\n *  Duration format plugin function for the Moment.js library\n *  http://momentjs.com/\n *\n *  Copyright 2018 John Madhavan-Reese\n *  Released under the MIT license\n */\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['moment'], factory);\n    } else if (typeof exports === 'object') {\n        // Node. Does not work with strict CommonJS, but only CommonJS-like\n        // enviroments that support module.exports, like Node.\n        try {\n            module.exports = factory(require('moment'));\n        } catch (e) {\n            // If moment is not available, leave the setup up to the user.\n            // Like when using moment-timezone or similar moment-based package.\n            module.exports = factory;\n        }\n    }\n\n    if (root) {\n        // Globals.\n        root.momentDurationFormatSetup = root.moment ? factory(root.moment) : factory;\n    }\n})(this, function (moment) {\n    // `Number#tolocaleString` is tested on plugin initialization.\n    // If the feature test passes, `toLocaleStringWorks` will be set to `true` and the\n    // native function will be used to generate formatted output. If the feature\n    // test fails, the fallback format function internal to this plugin will be\n    // used.\n    var toLocaleStringWorks = false;\n\n    // `Number#toLocaleString` rounds incorrectly for select numbers in Microsoft\n    // environments (Edge, IE11, Windows Phone) and possibly other environments.\n    // If the rounding test fails and `toLocaleString` will be used for formatting,\n    // the plugin will \"pre-round\" number values using the fallback number format\n    // function before passing them to `toLocaleString` for final formatting.\n    var toLocaleStringRoundingWorks = false;\n\n    // Token type names in order of descending magnitude.\n    var types = \"escape years months weeks days hours minutes seconds milliseconds general\".split(\" \");\n\n    var bubbles = [\n        {\n            type: \"seconds\",\n            targets: [\n                { type: \"minutes\", value: 60 },\n                { type: \"hours\", value: 3600 },\n                { type: \"days\", value: 86400 },\n                { type: \"weeks\", value: 604800 },\n                { type: \"months\", value: 2678400 },\n                { type: \"years\", value: 31536000 }\n            ]\n        },\n        {\n            type: \"minutes\",\n            targets: [\n                { type: \"hours\", value: 60 },\n                { type: \"days\", value: 1440 },\n                { type: \"weeks\", value: 10080 },\n                { type: \"months\", value: 44640 },\n                { type: \"years\", value: 525600 }\n            ]\n        },\n        {\n            type: \"hours\",\n            targets: [\n                { type: \"days\", value: 24 },\n                { type: \"weeks\", value: 168 },\n                { type: \"months\", value: 744 },\n                { type: \"years\", value: 8760 }\n            ]\n        },\n        {\n            type: \"days\",\n            targets: [\n                { type: \"weeks\", value: 7 },\n                { type: \"months\", value: 31 },\n                { type: \"years\", value: 365 }\n            ]\n        },\n        {\n            type: \"months\",\n            targets: [\n                { type: \"years\", value: 12 }\n            ]\n        }\n    ];\n\n    // stringIncludes\n    function stringIncludes(str, search) {\n        if (search.length > str.length) {\n          return false;\n        }\n\n        return str.indexOf(search) !== -1;\n    }\n\n    // repeatZero(qty)\n    // Returns \"0\" repeated `qty` times.\n    // `qty` must be a integer >= 0.\n    function repeatZero(qty) {\n        var result = \"\";\n\n        while (qty) {\n            result += \"0\";\n            qty -= 1;\n        }\n\n        return result;\n    }\n\n    function stringRound(digits) {\n        var digitsArray = digits.split(\"\").reverse();\n        var i = 0;\n        var carry = true;\n\n        while (carry && i < digitsArray.length) {\n            if (i) {\n                if (digitsArray[i] === \"9\") {\n                    digitsArray[i] = \"0\";\n                } else {\n                    digitsArray[i] = (parseInt(digitsArray[i], 10) + 1).toString();\n                    carry = false;\n                }\n            } else {\n                if (parseInt(digitsArray[i], 10) < 5) {\n                    carry = false;\n                }\n\n                digitsArray[i] = \"0\";\n            }\n\n            i += 1;\n        }\n\n        if (carry) {\n            digitsArray.push(\"1\");\n        }\n\n        return digitsArray.reverse().join(\"\");\n    }\n\n    // formatNumber\n    // Formats any number greater than or equal to zero using these options:\n    // - userLocale\n    // - useToLocaleString\n    // - useGrouping\n    // - grouping\n    // - maximumSignificantDigits\n    // - minimumIntegerDigits\n    // - fractionDigits\n    // - groupingSeparator\n    // - decimalSeparator\n    //\n    // `useToLocaleString` will use `toLocaleString` for formatting.\n    // `userLocale` option is passed through to `toLocaleString`.\n    // `fractionDigits` is passed through to `maximumFractionDigits` and `minimumFractionDigits`\n    // Using `maximumSignificantDigits` will override `minimumIntegerDigits` and `fractionDigits`.\n    function formatNumber(number, options, userLocale) {\n        var useToLocaleString = options.useToLocaleString;\n        var useGrouping = options.useGrouping;\n        var grouping = useGrouping && options.grouping.slice();\n        var maximumSignificantDigits = options.maximumSignificantDigits;\n        var minimumIntegerDigits = options.minimumIntegerDigits || 1;\n        var fractionDigits = options.fractionDigits || 0;\n        var groupingSeparator = options.groupingSeparator;\n        var decimalSeparator = options.decimalSeparator;\n\n        if (useToLocaleString && userLocale) {\n            var localeStringOptions = {\n                minimumIntegerDigits: minimumIntegerDigits,\n                useGrouping: useGrouping\n            };\n\n            if (fractionDigits) {\n                localeStringOptions.maximumFractionDigits = fractionDigits;\n                localeStringOptions.minimumFractionDigits = fractionDigits;\n            }\n\n            // toLocaleString output is \"0.0\" instead of \"0\" for HTC browsers\n            // when maximumSignificantDigits is set. See #96.\n            if (maximumSignificantDigits && number > 0) {\n                localeStringOptions.maximumSignificantDigits = maximumSignificantDigits;\n            }\n\n            if (!toLocaleStringRoundingWorks) {\n                var roundingOptions = extend({}, options);\n                roundingOptions.useGrouping = false;\n                roundingOptions.decimalSeparator = \".\";\n                number = parseFloat(formatNumber(number, roundingOptions), 10);\n            }\n\n            return number.toLocaleString(userLocale, localeStringOptions);\n        }\n\n        var numberString;\n\n        // Add 1 to digit output length for floating point errors workaround. See below.\n        if (maximumSignificantDigits) {\n            numberString = number.toPrecision(maximumSignificantDigits + 1);\n        } else {\n            numberString = number.toFixed(fractionDigits + 1);\n        }\n\n        var integerString;\n        var fractionString;\n        var exponentString;\n\n        var temp = numberString.split(\"e\");\n\n        exponentString = temp[1] || \"\";\n\n        temp = temp[0].split(\".\");\n\n        fractionString = temp[1] || \"\";\n        integerString = temp[0] || \"\";\n\n        // Workaround for floating point errors in `toFixed` and `toPrecision`.\n        // (3.55).toFixed(1); --> \"3.5\"\n        // (123.55 - 120).toPrecision(2); --> \"3.5\"\n        // (123.55 - 120); --> 3.549999999999997\n        // (123.55 - 120).toFixed(2); --> \"3.55\"\n        // Round by examing the string output of the next digit.\n\n        // *************** Implement String Rounding here ***********************\n        // Check integerString + fractionString length of toPrecision before rounding.\n        // Check length of fractionString from toFixed output before rounding.\n        var integerLength = integerString.length;\n        var fractionLength = fractionString.length;\n        var digitCount = integerLength + fractionLength;\n        var digits = integerString + fractionString;\n\n        if (maximumSignificantDigits && digitCount === (maximumSignificantDigits + 1) || !maximumSignificantDigits && fractionLength === (fractionDigits + 1)) {\n            // Round digits.\n            digits = stringRound(digits);\n\n            if (digits.length === digitCount + 1) {\n                integerLength = integerLength + 1;\n            }\n\n            // Discard final fractionDigit.\n            if (fractionLength) {\n                digits = digits.slice(0, -1);\n            }\n\n            // Separate integer and fraction.\n            integerString = digits.slice(0, integerLength);\n            fractionString = digits.slice(integerLength);\n        }\n\n        // Trim trailing zeroes from fractionString because toPrecision outputs\n        // precision, not significant digits.\n        if (maximumSignificantDigits) {\n            fractionString = fractionString.replace(/0*$/, \"\");\n        }\n\n        // Handle exponent.\n        var exponent = parseInt(exponentString, 10);\n\n        if (exponent > 0) {\n            if (fractionString.length <= exponent) {\n                fractionString = fractionString + repeatZero(exponent - fractionString.length);\n\n                integerString = integerString + fractionString;\n                fractionString = \"\";\n            } else {\n                integerString = integerString + fractionString.slice(0, exponent);\n                fractionString = fractionString.slice(exponent);\n            }\n        } else if (exponent < 0) {\n            fractionString = (repeatZero(Math.abs(exponent) - integerString.length) + integerString + fractionString);\n\n            integerString = \"0\";\n        }\n\n        if (!maximumSignificantDigits) {\n            // Trim or pad fraction when not using maximumSignificantDigits.\n            fractionString = fractionString.slice(0, fractionDigits);\n\n            if (fractionString.length < fractionDigits) {\n                fractionString = fractionString + repeatZero(fractionDigits - fractionString.length);\n            }\n\n            // Pad integer when using minimumIntegerDigits\n            // and not using maximumSignificantDigits.\n            if (integerString.length < minimumIntegerDigits) {\n                integerString = repeatZero(minimumIntegerDigits - integerString.length) + integerString;\n            }\n        }\n\n        var formattedString = \"\";\n\n        // Handle grouping.\n        if (useGrouping) {\n            temp = integerString;\n            var group;\n\n            while (temp.length) {\n                if (grouping.length) {\n                    group = grouping.shift();\n                }\n\n                if (formattedString) {\n                    formattedString = groupingSeparator + formattedString;\n                }\n\n                formattedString = temp.slice(-group) + formattedString;\n\n                temp = temp.slice(0, -group);\n            }\n        } else {\n            formattedString = integerString;\n        }\n\n        // Add decimalSeparator and fraction.\n        if (fractionString) {\n            formattedString = formattedString + decimalSeparator + fractionString;\n        }\n\n        return formattedString;\n    }\n\n    // durationLabelCompare\n    function durationLabelCompare(a, b) {\n        if (a.label.length > b.label.length) {\n            return -1;\n        }\n\n        if (a.label.length < b.label.length) {\n            return 1;\n        }\n\n        // a must be equal to b\n        return 0;\n    }\n\n    // durationGetLabels\n    function durationGetLabels(token, localeData) {\n        var labels = [];\n\n        each(keys(localeData), function (localeDataKey) {\n            if (localeDataKey.slice(0, 15) !== \"_durationLabels\") {\n                return;\n            }\n\n            var labelType = localeDataKey.slice(15).toLowerCase();\n\n            each(keys(localeData[localeDataKey]), function (labelKey) {\n                if (labelKey.slice(0, 1) === token) {\n                    labels.push({\n                        type: labelType,\n                        key: labelKey,\n                        label: localeData[localeDataKey][labelKey]\n                    });\n                }\n            });\n        });\n\n        return labels;\n    }\n\n    // durationPluralKey\n    function durationPluralKey(token, integerValue, decimalValue) {\n        // Singular for a value of `1`, but not for `1.0`.\n        if (integerValue === 1 && decimalValue === null) {\n            return token;\n        }\n\n        return token + token;\n    }\n\n    var engLocale = {\n        durationLabelsStandard: {\n            S: 'millisecond',\n            SS: 'milliseconds',\n            s: 'second',\n            ss: 'seconds',\n            m: 'minute',\n            mm: 'minutes',\n            h: 'hour',\n            hh: 'hours',\n            d: 'day',\n            dd: 'days',\n            w: 'week',\n            ww: 'weeks',\n            M: 'month',\n            MM: 'months',\n            y: 'year',\n            yy: 'years'\n        },\n        durationLabelsShort: {\n            S: 'msec',\n            SS: 'msecs',\n            s: 'sec',\n            ss: 'secs',\n            m: 'min',\n            mm: 'mins',\n            h: 'hr',\n            hh: 'hrs',\n            d: 'dy',\n            dd: 'dys',\n            w: 'wk',\n            ww: 'wks',\n            M: 'mo',\n            MM: 'mos',\n            y: 'yr',\n            yy: 'yrs'\n        },\n        durationTimeTemplates: {\n            HMS: 'h:mm:ss',\n            HM: 'h:mm',\n            MS: 'm:ss'\n        },\n        durationLabelTypes: [\n            { type: \"standard\", string: \"__\" },\n            { type: \"short\", string: \"_\" }\n        ],\n        durationPluralKey: durationPluralKey\n    };\n\n    // isArray\n    function isArray(array) {\n        return Object.prototype.toString.call(array) === \"[object Array]\";\n    }\n\n    // isObject\n    function isObject(obj) {\n        return Object.prototype.toString.call(obj) === \"[object Object]\";\n    }\n\n    // findLast\n    function findLast(array, callback) {\n        var index = array.length;\n\n        while (index -= 1) {\n            if (callback(array[index])) { return array[index]; }\n        }\n    }\n\n    // find\n    function find(array, callback) {\n        var index = 0;\n\n        var max = array && array.length || 0;\n\n        var match;\n\n        if (typeof callback !== \"function\") {\n            match = callback;\n            callback = function (item) {\n                return item === match;\n            };\n        }\n\n        while (index < max) {\n            if (callback(array[index])) { return array[index]; }\n            index += 1;\n        }\n    }\n\n    // each\n    function each(array, callback) {\n        var index = 0,\n            max = array.length;\n\n        if (!array || !max) { return; }\n\n        while (index < max) {\n            if (callback(array[index], index) === false) { return; }\n            index += 1;\n        }\n    }\n\n    // map\n    function map(array, callback) {\n        var index = 0,\n            max = array.length,\n            ret = [];\n\n        if (!array || !max) { return ret; }\n\n        while (index < max) {\n            ret[index] = callback(array[index], index);\n            index += 1;\n        }\n\n        return ret;\n    }\n\n    // pluck\n    function pluck(array, prop) {\n        return map(array, function (item) {\n            return item[prop];\n        });\n    }\n\n    // compact\n    function compact(array) {\n        var ret = [];\n\n        each(array, function (item) {\n            if (item) { ret.push(item); }\n        });\n\n        return ret;\n    }\n\n    // unique\n    function unique(array) {\n        var ret = [];\n\n        each(array, function (_a) {\n            if (!find(ret, _a)) { ret.push(_a); }\n        });\n\n        return ret;\n    }\n\n    // intersection\n    function intersection(a, b) {\n        var ret = [];\n\n        each(a, function (_a) {\n            each(b, function (_b) {\n                if (_a === _b) { ret.push(_a); }\n            });\n        });\n\n        return unique(ret);\n    }\n\n    // rest\n    function rest(array, callback) {\n        var ret = [];\n\n        each(array, function (item, index) {\n            if (!callback(item)) {\n                ret = array.slice(index);\n                return false;\n            }\n        });\n\n        return ret;\n    }\n\n    // initial\n    function initial(array, callback) {\n        var reversed = array.slice().reverse();\n\n        return rest(reversed, callback).reverse();\n    }\n\n    // extend\n    function extend(a, b) {\n        for (var key in b) {\n            if (b.hasOwnProperty(key)) { a[key] = b[key]; }\n        }\n\n        return a;\n    }\n\n    // keys\n    function keys(a) {\n        var ret = [];\n\n        for (var key in a) {\n            if (a.hasOwnProperty(key)) { ret.push(key); }\n        }\n\n        return ret;\n    }\n\n    // any\n    function any(array, callback) {\n        var index = 0,\n            max = array.length;\n\n        if (!array || !max) { return false; }\n\n        while (index < max) {\n            if (callback(array[index], index) === true) { return true; }\n            index += 1;\n        }\n\n        return false;\n    }\n\n    // flatten\n    function flatten(array) {\n        var ret = [];\n\n        each(array, function(child) {\n            ret = ret.concat(child);\n        });\n\n        return ret;\n    }\n\n    function toLocaleStringSupportsLocales() {\n        var number = 0;\n        try {\n            number.toLocaleString('i');\n        } catch (e) {\n            return e.name === 'RangeError';\n        }\n        return false;\n    }\n\n    function featureTestToLocaleStringRounding() {\n        return (3.55).toLocaleString(\"en\", {\n            useGrouping: false,\n            minimumIntegerDigits: 1,\n            minimumFractionDigits: 1,\n            maximumFractionDigits: 1\n        }) === \"3.6\";\n    }\n\n    function featureTestToLocaleString() {\n        var passed = true;\n\n        // Test locale.\n        passed = passed && toLocaleStringSupportsLocales();\n        if (!passed) { return false; }\n\n        // Test minimumIntegerDigits.\n        passed = passed && (1).toLocaleString(\"en\", { minimumIntegerDigits: 1 }) === \"1\";\n        passed = passed && (1).toLocaleString(\"en\", { minimumIntegerDigits: 2 }) === \"01\";\n        passed = passed && (1).toLocaleString(\"en\", { minimumIntegerDigits: 3 }) === \"001\";\n        if (!passed) { return false; }\n\n        // Test maximumFractionDigits and minimumFractionDigits.\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumFractionDigits: 0, minimumFractionDigits: 0 }) === \"100\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumFractionDigits: 1, minimumFractionDigits: 1 }) === \"100.0\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumFractionDigits: 2, minimumFractionDigits: 2 }) === \"99.99\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumFractionDigits: 3, minimumFractionDigits: 3 }) === \"99.990\";\n        if (!passed) { return false; }\n\n        // Test maximumSignificantDigits.\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 1 }) === \"100\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 2 }) === \"100\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 3 }) === \"100\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 4 }) === \"99.99\";\n        passed = passed && (99.99).toLocaleString(\"en\", { maximumSignificantDigits: 5 }) === \"99.99\";\n        if (!passed) { return false; }\n\n        // Test grouping.\n        passed = passed && (1000).toLocaleString(\"en\", { useGrouping: true }) === \"1,000\";\n        passed = passed && (1000).toLocaleString(\"en\", { useGrouping: false }) === \"1000\";\n        if (!passed) { return false; }\n\n        return true;\n    }\n\n    // durationsFormat(durations [, template] [, precision] [, settings])\n    function durationsFormat() {\n        var args = [].slice.call(arguments);\n        var settings = {};\n        var durations;\n\n        // Parse arguments.\n        each(args, function (arg, index) {\n            if (!index) {\n                if (!isArray(arg)) {\n                    throw \"Expected array as the first argument to durationsFormat.\";\n                }\n\n                durations = arg;\n            }\n\n            if (typeof arg === \"string\" || typeof arg === \"function\") {\n                settings.template = arg;\n                return;\n            }\n\n            if (typeof arg === \"number\") {\n                settings.precision = arg;\n                return;\n            }\n\n            if (isObject(arg)) {\n                extend(settings, arg);\n            }\n        });\n\n        if (!durations || !durations.length) {\n            return [];\n        }\n\n        settings.returnMomentTypes = true;\n\n        var formattedDurations = map(durations, function (dur) {\n            return dur.format(settings);\n        });\n\n        // Merge token types from all durations.\n        var outputTypes = intersection(types, unique(pluck(flatten(formattedDurations), \"type\")));\n\n        var largest = settings.largest;\n\n        if (largest) {\n            outputTypes = outputTypes.slice(0, largest);\n        }\n\n        settings.returnMomentTypes = false;\n        settings.outputTypes = outputTypes;\n\n        return map(durations, function (dur) {\n            return dur.format(settings);\n        });\n    }\n\n    // durationFormat([template] [, precision] [, settings])\n    function durationFormat() {\n\n        var args = [].slice.call(arguments);\n        var settings = extend({}, this.format.defaults);\n\n        // Keep a shadow copy of this moment for calculating remainders.\n        // Perform all calculations on positive duration value, handle negative\n        // sign at the very end.\n        var asMilliseconds = this.asMilliseconds();\n        var asMonths = this.asMonths();\n\n        // Treat invalid durations as having a value of 0 milliseconds.\n        if (this.isValid() === false) {\n            asMilliseconds = 0;\n            asMonths = 0;\n        }\n\n        var isNegative = asMilliseconds < 0;\n\n        // Two shadow copies are needed because of the way moment.js handles\n        // duration arithmetic for years/months and for weeks/days/hours/minutes/seconds.\n        var remainder = moment.duration(Math.abs(asMilliseconds), \"milliseconds\");\n        var remainderMonths = moment.duration(Math.abs(asMonths), \"months\");\n\n        // Parse arguments.\n        each(args, function (arg) {\n            if (typeof arg === \"string\" || typeof arg === \"function\") {\n                settings.template = arg;\n                return;\n            }\n\n            if (typeof arg === \"number\") {\n                settings.precision = arg;\n                return;\n            }\n\n            if (isObject(arg)) {\n                extend(settings, arg);\n            }\n        });\n\n        var momentTokens = {\n            years: \"y\",\n            months: \"M\",\n            weeks: \"w\",\n            days: \"d\",\n            hours: \"h\",\n            minutes: \"m\",\n            seconds: \"s\",\n            milliseconds: \"S\"\n        };\n\n        var tokenDefs = {\n            escape: /\\[(.+?)\\]/,\n            years: /\\*?[Yy]+/,\n            months: /\\*?M+/,\n            weeks: /\\*?[Ww]+/,\n            days: /\\*?[Dd]+/,\n            hours: /\\*?[Hh]+/,\n            minutes: /\\*?m+/,\n            seconds: /\\*?s+/,\n            milliseconds: /\\*?S+/,\n            general: /.+?/\n        };\n\n        // Types array is available in the template function.\n        settings.types = types;\n\n        var typeMap = function (token) {\n            return find(types, function (type) {\n                return tokenDefs[type].test(token);\n            });\n        };\n\n        var tokenizer = new RegExp(map(types, function (type) {\n            return tokenDefs[type].source;\n        }).join(\"|\"), \"g\");\n\n        // Current duration object is available in the template function.\n        settings.duration = this;\n\n        // Eval template function and cache template string.\n        var template = typeof settings.template === \"function\" ? settings.template.apply(settings) : settings.template;\n\n        // outputTypes and returnMomentTypes are settings to support durationsFormat().\n\n        // outputTypes is an array of moment token types that determines\n        // the tokens returned in formatted output. This option overrides\n        // trim, largest, stopTrim, etc.\n        var outputTypes = settings.outputTypes;\n\n        // returnMomentTypes is a boolean that sets durationFormat to return\n        // the processed momentTypes instead of formatted output.\n        var returnMomentTypes = settings.returnMomentTypes;\n\n        var largest = settings.largest;\n\n        // Setup stopTrim array of token types.\n        var stopTrim = [];\n\n        if (!outputTypes) {\n            if (isArray(settings.stopTrim)) {\n                settings.stopTrim = settings.stopTrim.join(\"\");\n            }\n\n            // Parse stopTrim string to create token types array.\n            if (settings.stopTrim) {\n                each(settings.stopTrim.match(tokenizer), function (token) {\n                    var type = typeMap(token);\n\n                    if (type === \"escape\" || type === \"general\") {\n                        return;\n                    }\n\n                    stopTrim.push(type);\n                });\n            }\n        }\n\n        // Cache moment's locale data.\n        var localeData = moment.localeData();\n\n        if (!localeData) {\n            localeData = {};\n        }\n\n        // Fall back to this plugin's `eng` extension.\n        each(keys(engLocale), function (key) {\n            if (typeof engLocale[key] === \"function\") {\n                if (!localeData[key]) {\n                    localeData[key] = engLocale[key];\n                }\n\n                return;\n            }\n\n            if (!localeData[\"_\" + key]) {\n                localeData[\"_\" + key] = engLocale[key];\n            }\n        });\n\n        // Replace Duration Time Template strings.\n        // For locale `eng`: `_HMS_`, `_HM_`, and `_MS_`.\n        each(keys(localeData._durationTimeTemplates), function (item) {\n            template = template.replace(\"_\" + item + \"_\", localeData._durationTimeTemplates[item]);\n        });\n\n        // Determine user's locale.\n        var userLocale = settings.userLocale || moment.locale();\n\n        var useLeftUnits = settings.useLeftUnits;\n        var usePlural = settings.usePlural;\n        var precision = settings.precision;\n        var forceLength = settings.forceLength;\n        var useGrouping = settings.useGrouping;\n        var trunc = settings.trunc;\n\n        // Use significant digits only when precision is greater than 0.\n        var useSignificantDigits = settings.useSignificantDigits && precision > 0;\n        var significantDigits = useSignificantDigits ? settings.precision : 0;\n        var significantDigitsCache = significantDigits;\n\n        var minValue = settings.minValue;\n        var isMinValue = false;\n\n        var maxValue = settings.maxValue;\n        var isMaxValue = false;\n\n        // formatNumber fallback options.\n        var useToLocaleString = settings.useToLocaleString;\n        var groupingSeparator = settings.groupingSeparator;\n        var decimalSeparator = settings.decimalSeparator;\n        var grouping = settings.grouping;\n\n        useToLocaleString = useToLocaleString && toLocaleStringWorks;\n\n        // Trim options.\n        var trim = settings.trim;\n\n        if (isArray(trim)) {\n            trim = trim.join(\" \");\n        }\n\n        if (trim === null && (largest || maxValue || useSignificantDigits)) {\n            trim = \"all\";\n        }\n\n        if (trim === null || trim === true || trim === \"left\" || trim === \"right\") {\n            trim = \"large\";\n        }\n\n        if (trim === false) {\n            trim = \"\";\n        }\n\n        var trimIncludes = function (item) {\n            return item.test(trim);\n        };\n\n        var rLarge = /large/;\n        var rSmall = /small/;\n        var rBoth = /both/;\n        var rMid = /mid/;\n        var rAll = /^all|[^sm]all/;\n        var rFinal = /final/;\n\n        var trimLarge = largest > 0 || any([rLarge, rBoth, rAll], trimIncludes);\n        var trimSmall = any([rSmall, rBoth, rAll], trimIncludes);\n        var trimMid = any([rMid, rAll], trimIncludes);\n        var trimFinal = any([rFinal, rAll], trimIncludes);\n\n        // Parse format string to create raw tokens array.\n        var rawTokens = map(template.match(tokenizer), function (token, index) {\n            var type = typeMap(token);\n\n            if (token.slice(0, 1) === \"*\") {\n                token = token.slice(1);\n\n                if (type !== \"escape\" && type !== \"general\") {\n                    stopTrim.push(type);\n                }\n            }\n\n            return {\n                index: index,\n                length: token.length,\n                text: \"\",\n\n                // Replace escaped tokens with the non-escaped token text.\n                token: (type === \"escape\" ? token.replace(tokenDefs.escape, \"$1\") : token),\n\n                // Ignore type on non-moment tokens.\n                type: ((type === \"escape\" || type === \"general\") ? null : type)\n            };\n        });\n\n        // Associate text tokens with moment tokens.\n        var currentToken = {\n            index: 0,\n            length: 0,\n            token: \"\",\n            text: \"\",\n            type: null\n        };\n\n        var tokens = [];\n\n        if (useLeftUnits) {\n            rawTokens.reverse();\n        }\n\n        each(rawTokens, function (token) {\n            if (token.type) {\n                if (currentToken.type || currentToken.text) {\n                    tokens.push(currentToken);\n                }\n\n                currentToken = token;\n\n                return;\n            }\n\n            if (useLeftUnits) {\n                currentToken.text = token.token + currentToken.text;\n            } else {\n                currentToken.text += token.token;\n            }\n        });\n\n        if (currentToken.type || currentToken.text) {\n            tokens.push(currentToken);\n        }\n\n        if (useLeftUnits) {\n            tokens.reverse();\n        }\n\n        // Find unique moment token types in the template in order of\n        // descending magnitude.\n        var momentTypes = intersection(types, unique(compact(pluck(tokens, \"type\"))));\n\n        // Exit early if there are no moment token types.\n        if (!momentTypes.length) {\n            return pluck(tokens, \"text\").join(\"\");\n        }\n\n        // Calculate values for each moment type in the template.\n        // For processing the settings, values are associated with moment types.\n        // Values will be assigned to tokens at the last step in order to\n        // assume nothing about frequency or order of tokens in the template.\n        momentTypes = map(momentTypes, function (momentType, index) {\n            // Is this the least-magnitude moment token found?\n            var isSmallest = ((index + 1) === momentTypes.length);\n\n            // Is this the greatest-magnitude moment token found?\n            var isLargest = (!index);\n\n            // Get the raw value in the current units.\n            var rawValue;\n\n            if (momentType === \"years\" || momentType === \"months\") {\n                rawValue = remainderMonths.as(momentType);\n            } else {\n                rawValue = remainder.as(momentType);\n            }\n\n            var wholeValue = Math.floor(rawValue);\n            var decimalValue = rawValue - wholeValue;\n\n            var token = find(tokens, function (token) {\n                return momentType === token.type;\n            });\n\n            if (isLargest && maxValue && rawValue > maxValue) {\n                isMaxValue = true;\n            }\n\n            if (isSmallest && minValue && Math.abs(settings.duration.as(momentType)) < minValue) {\n                isMinValue = true;\n            }\n\n            // Note the length of the largest-magnitude moment token:\n            // if it is greater than one and forceLength is not set,\n            // then default forceLength to `true`.\n            //\n            // Rationale is this: If the template is \"h:mm:ss\" and the\n            // moment value is 5 minutes, the user-friendly output is\n            // \"5:00\", not \"05:00\". We shouldn't pad the `minutes` token\n            // even though it has length of two if the template is \"h:mm:ss\";\n            //\n            // If the minutes output should always include the leading zero\n            // even when the hour is trimmed then set `{ forceLength: true }`\n            // to output \"05:00\". If the template is \"hh:mm:ss\", the user\n            // clearly wanted everything padded so we should output \"05:00\";\n            //\n            // If the user wants the full padded output, they can use\n            // template \"hh:mm:ss\" and set `{ trim: false }` to output\n            // \"00:05:00\".\n            if (isLargest && forceLength === null && token.length > 1) {\n                forceLength = true;\n            }\n\n            // Update remainder.\n            remainder.subtract(wholeValue, momentType);\n            remainderMonths.subtract(wholeValue, momentType);\n\n            return {\n                rawValue: rawValue,\n                wholeValue: wholeValue,\n                // Decimal value is only retained for the least-magnitude\n                // moment type in the format template.\n                decimalValue: isSmallest ? decimalValue : 0,\n                isSmallest: isSmallest,\n                isLargest: isLargest,\n                type: momentType,\n                // Tokens can appear multiple times in a template string,\n                // but all instances must share the same length.\n                tokenLength: token.length\n            };\n        });\n\n        var truncMethod = trunc ? Math.floor : Math.round;\n        var truncate = function (value, places) {\n            var factor = Math.pow(10, places);\n            return truncMethod(value * factor) / factor;\n        };\n\n        var foundFirst = false;\n        var bubbled = false;\n\n        var formatValue = function (momentType, index) {\n            var formatOptions = {\n                useGrouping: useGrouping,\n                groupingSeparator: groupingSeparator,\n                decimalSeparator: decimalSeparator,\n                grouping: grouping,\n                useToLocaleString: useToLocaleString\n            };\n\n            if (useSignificantDigits) {\n                if (significantDigits <= 0) {\n                    momentType.rawValue = 0;\n                    momentType.wholeValue = 0;\n                    momentType.decimalValue = 0;\n                } else {\n                    formatOptions.maximumSignificantDigits = significantDigits;\n                    momentType.significantDigits = significantDigits;\n                }\n            }\n\n            if (isMaxValue && !bubbled) {\n                if (momentType.isLargest) {\n                    momentType.wholeValue = maxValue;\n                    momentType.decimalValue = 0;\n                } else {\n                    momentType.wholeValue = 0;\n                    momentType.decimalValue = 0;\n                }\n            }\n\n            if (isMinValue && !bubbled) {\n                if (momentType.isSmallest) {\n                    momentType.wholeValue = minValue;\n                    momentType.decimalValue = 0;\n                } else {\n                    momentType.wholeValue = 0;\n                    momentType.decimalValue = 0;\n                }\n            }\n\n            if (momentType.isSmallest || momentType.significantDigits && momentType.significantDigits - momentType.wholeValue.toString().length <= 0) {\n                // Apply precision to least significant token value.\n                if (precision < 0) {\n                    momentType.value = truncate(momentType.wholeValue, precision);\n                } else if (precision === 0) {\n                    momentType.value = truncMethod(momentType.wholeValue + momentType.decimalValue);\n                } else { // precision > 0\n                    if (useSignificantDigits) {\n                        if (trunc) {\n                            momentType.value = truncate(momentType.rawValue, significantDigits - momentType.wholeValue.toString().length);\n                        } else {\n                            momentType.value = momentType.rawValue;\n                        }\n\n                        if (momentType.wholeValue) {\n                            significantDigits -= momentType.wholeValue.toString().length;\n                        }\n                    } else {\n                        formatOptions.fractionDigits = precision;\n\n                        if (trunc) {\n                            momentType.value = momentType.wholeValue + truncate(momentType.decimalValue, precision);\n                        } else {\n                            momentType.value = momentType.wholeValue + momentType.decimalValue;\n                        }\n                    }\n                }\n            } else {\n                if (useSignificantDigits && momentType.wholeValue) {\n                    // Outer Math.round required here to handle floating point errors.\n                    momentType.value = Math.round(truncate(momentType.wholeValue, momentType.significantDigits - momentType.wholeValue.toString().length));\n\n                    significantDigits -= momentType.wholeValue.toString().length;\n                } else {\n                    momentType.value = momentType.wholeValue;\n                }\n            }\n\n            if (momentType.tokenLength > 1 && (forceLength || foundFirst)) {\n                formatOptions.minimumIntegerDigits = momentType.tokenLength;\n\n                if (bubbled && formatOptions.maximumSignificantDigits < momentType.tokenLength) {\n                    delete formatOptions.maximumSignificantDigits;\n                }\n            }\n\n            if (!foundFirst && (momentType.value > 0 || trim === \"\" /* trim: false */ || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n                foundFirst = true;\n            }\n\n            momentType.formattedValue = formatNumber(momentType.value, formatOptions, userLocale);\n\n            formatOptions.useGrouping = false;\n            formatOptions.decimalSeparator = \".\";\n            momentType.formattedValueEn = formatNumber(momentType.value, formatOptions, \"en\");\n\n            if (momentType.tokenLength === 2 && momentType.type === \"milliseconds\") {\n                momentType.formattedValueMS = formatNumber(momentType.value, {\n                    minimumIntegerDigits: 3,\n                    useGrouping: false\n                }, \"en\").slice(0, 2);\n            }\n\n            return momentType;\n        };\n\n        // Calculate formatted values.\n        momentTypes = map(momentTypes, formatValue);\n        momentTypes = compact(momentTypes);\n\n        // Bubble rounded values.\n        if (momentTypes.length > 1) {\n            var findType = function (type) {\n                return find(momentTypes, function (momentType) {\n                    return momentType.type === type;\n                });\n            };\n\n            var bubbleTypes = function (bubble) {\n                var bubbleMomentType = findType(bubble.type);\n\n                if (!bubbleMomentType) {\n                    return;\n                }\n\n                each(bubble.targets, function (target) {\n                    var targetMomentType = findType(target.type);\n\n                    if (!targetMomentType) {\n                        return;\n                    }\n\n                    if (parseInt(bubbleMomentType.formattedValueEn, 10) === target.value) {\n                        bubbleMomentType.rawValue = 0;\n                        bubbleMomentType.wholeValue = 0;\n                        bubbleMomentType.decimalValue = 0;\n                        targetMomentType.rawValue += 1;\n                        targetMomentType.wholeValue += 1;\n                        targetMomentType.decimalValue = 0;\n                        targetMomentType.formattedValueEn = targetMomentType.wholeValue.toString();\n                        bubbled = true;\n                    }\n                });\n            };\n\n            each(bubbles, bubbleTypes);\n        }\n\n        // Recalculate formatted values.\n        if (bubbled) {\n            foundFirst = false;\n            significantDigits = significantDigitsCache;\n            momentTypes = map(momentTypes, formatValue);\n            momentTypes = compact(momentTypes);\n        }\n\n        if (outputTypes && !(isMaxValue && !settings.trim)) {\n            momentTypes = map(momentTypes, function (momentType) {\n                if (find(outputTypes, function (outputType) {\n                    return momentType.type === outputType;\n                })) {\n                    return momentType;\n                }\n\n                return null;\n            });\n\n            momentTypes = compact(momentTypes);\n        } else {\n            // Trim Large.\n            if (trimLarge) {\n                momentTypes = rest(momentTypes, function (momentType) {\n                    // Stop trimming on:\n                    // - the smallest moment type\n                    // - a type marked for stopTrim\n                    // - a type that has a whole value\n                    return !momentType.isSmallest && !momentType.wholeValue && !find(stopTrim, momentType.type);\n                });\n            }\n\n            // Largest.\n            if (largest && momentTypes.length) {\n                momentTypes = momentTypes.slice(0, largest);\n            }\n\n            // Trim Small.\n            if (trimSmall && momentTypes.length > 1) {\n                momentTypes = initial(momentTypes, function (momentType) {\n                    // Stop trimming on:\n                    // - a type marked for stopTrim\n                    // - a type that has a whole value\n                    // - the largest momentType\n                    return !momentType.wholeValue && !find(stopTrim, momentType.type) && !momentType.isLargest;\n                });\n            }\n\n            // Trim Mid.\n            if (trimMid) {\n                momentTypes = map(momentTypes, function (momentType, index) {\n                    if (index > 0 && index < momentTypes.length - 1 && !momentType.wholeValue) {\n                        return null;\n                    }\n\n                    return momentType;\n                });\n\n                momentTypes = compact(momentTypes);\n            }\n\n            // Trim Final.\n            if (trimFinal && momentTypes.length === 1 && !momentTypes[0].wholeValue && !(!trunc && momentTypes[0].isSmallest && momentTypes[0].rawValue < minValue)) {\n                momentTypes = [];\n            }\n        }\n\n        if (returnMomentTypes) {\n            return momentTypes;\n        }\n\n        // Localize and pluralize unit labels.\n        each(tokens, function (token) {\n            var key = momentTokens[token.type];\n\n            var momentType = find(momentTypes, function (momentType) {\n                return momentType.type === token.type;\n            });\n\n            if (!key || !momentType) {\n                return;\n            }\n\n            var values = momentType.formattedValueEn.split(\".\");\n\n            values[0] = parseInt(values[0], 10);\n\n            if (values[1]) {\n                values[1] = parseFloat(\"0.\" + values[1], 10);\n            } else {\n                values[1] = null;\n            }\n\n            var pluralKey = localeData.durationPluralKey(key, values[0], values[1]);\n\n            var labels = durationGetLabels(key, localeData);\n\n            var autoLocalized = false;\n\n            var pluralizedLabels = {};\n\n            // Auto-Localized unit labels.\n            each(localeData._durationLabelTypes, function (labelType) {\n                var label = find(labels, function (label) {\n                    return label.type === labelType.type && label.key === pluralKey;\n                });\n\n                if (label) {\n                    pluralizedLabels[label.type] = label.label;\n\n                    if (stringIncludes(token.text, labelType.string)) {\n                        token.text = token.text.replace(labelType.string, label.label);\n                        autoLocalized = true;\n                    }\n                }\n            });\n\n            // Auto-pluralized unit labels.\n            if (usePlural && !autoLocalized) {\n                labels.sort(durationLabelCompare);\n\n                each(labels, function (label) {\n                    if (pluralizedLabels[label.type] === label.label) {\n                        if (stringIncludes(token.text, label.label)) {\n                            // Stop checking this token if its label is already\n                            // correctly pluralized.\n                            return false;\n                        }\n\n                        // Skip this label if it is correct, but not present in\n                        // the token's text.\n                        return;\n                    }\n\n                    if (stringIncludes(token.text, label.label)) {\n                        // Replece this token's label and stop checking.\n                        token.text = token.text.replace(label.label, pluralizedLabels[label.type]);\n                        return false;\n                    }\n                });\n            }\n        });\n\n        // Build ouptut.\n        tokens = map(tokens, function (token) {\n            if (!token.type) {\n                return token.text;\n            }\n\n            var momentType = find(momentTypes, function (momentType) {\n                return momentType.type === token.type;\n            });\n\n            if (!momentType) {\n                return \"\";\n            }\n\n            var out = \"\";\n\n            if (useLeftUnits) {\n                out += token.text;\n            }\n\n            if (isNegative && isMaxValue || !isNegative && isMinValue) {\n                out += \"< \";\n                isMaxValue = false;\n                isMinValue = false;\n            }\n\n            if (isNegative && isMinValue || !isNegative && isMaxValue) {\n                out += \"> \";\n                isMaxValue = false;\n                isMinValue = false;\n            }\n\n            if (isNegative && (momentType.value > 0 || find(stopTrim, momentType.type) || find(outputTypes, momentType.type))) {\n                out += \"-\";\n                isNegative = false;\n            }\n\n            if (token.type === \"milliseconds\" && momentType.formattedValueMS) {\n                out += momentType.formattedValueMS;\n            } else {\n                out += momentType.formattedValue;\n            }\n\n            if (!useLeftUnits) {\n                out += token.text;\n            }\n\n            return out;\n        });\n\n        // Trim leading and trailing comma, space, colon, and dot.\n        return tokens.join(\"\").replace(/(,| |:|\\.)*$/, \"\").replace(/^(,| |:|\\.)*/, \"\");\n    }\n\n    // defaultFormatTemplate\n    function defaultFormatTemplate() {\n        var dur = this.duration;\n\n        var findType = function findType(type) {\n            return dur._data[type];\n        };\n\n        var firstType = find(this.types, findType);\n\n        var lastType = findLast(this.types, findType);\n\n        // Default template strings for each duration dimension type.\n        switch (firstType) {\n            case \"milliseconds\":\n                return \"S __\";\n            case \"seconds\": // Fallthrough.\n            case \"minutes\":\n                return \"*_MS_\";\n            case \"hours\":\n                return \"_HMS_\";\n            case \"days\": // Possible Fallthrough.\n                if (firstType === lastType) {\n                    return \"d __\";\n                }\n            case \"weeks\":\n                if (firstType === lastType) {\n                    return \"w __\";\n                }\n\n                if (this.trim === null) {\n                    this.trim = \"both\";\n                }\n\n                return \"w __, d __, h __\";\n            case \"months\": // Possible Fallthrough.\n                if (firstType === lastType) {\n                    return \"M __\";\n                }\n            case \"years\":\n                if (firstType === lastType) {\n                    return \"y __\";\n                }\n\n                if (this.trim === null) {\n                    this.trim = \"both\";\n                }\n\n                return \"y __, M __, d __\";\n            default:\n                if (this.trim === null) {\n                    this.trim = \"both\";\n                }\n\n                return \"y __, d __, h __, m __, s __\";\n        }\n    }\n\n    // init\n    function init(context) {\n        if (!context) {\n            throw \"Moment Duration Format init cannot find moment instance.\";\n        }\n\n        context.duration.format = durationsFormat;\n        context.duration.fn.format = durationFormat;\n\n        context.duration.fn.format.defaults = {\n            // Many options are defaulted to `null` to distinguish between\n            // 'not set' and 'set to `false`'\n\n            // trim\n            // Can be a string, a delimited list of strings, an array of strings,\n            // or a boolean.\n            // \"large\" - will trim largest-magnitude zero-value tokens until\n            // finding a token with a value, a token identified as 'stopTrim', or\n            // the final token of the format string.\n            // \"small\" - will trim smallest-magnitude zero-value tokens until\n            // finding a token with a value, a token identified as 'stopTrim', or\n            // the final token of the format string.\n            // \"both\" - will execute \"large\" trim then \"small\" trim.\n            // \"mid\" - will trim any zero-value tokens that are not the first or\n            // last tokens. Usually used in conjunction with \"large\" or \"both\".\n            // e.g. \"large mid\" or \"both mid\".\n            // \"final\" - will trim the final token if it is zero-value. Use this\n            // option with \"large\" or \"both\" to output an empty string when\n            // formatting a zero-value duration. e.g. \"large final\" or \"both final\".\n            // \"all\" - Will trim all zero-value tokens. Shorthand for \"both mid final\".\n            // \"left\" - maps to \"large\" to support plugin's version 1 API.\n            // \"right\" - maps to \"large\" to support plugin's version 1 API.\n            // `false` - template tokens are not trimmed.\n            // `true` - treated as \"large\".\n            // `null` - treated as \"large\".\n            trim: null,\n\n            // stopTrim\n            // A moment token string, a delimited set of moment token strings,\n            // or an array of moment token strings. Trimming will stop when a token\n            // listed in this option is reached. A \"*\" character in the format\n            // template string will also mark a moment token as stopTrim.\n            // e.g. \"d [days] *h:mm:ss\" will always stop trimming at the 'hours' token.\n            stopTrim: null,\n\n            // largest\n            // Set to a positive integer to output only the \"n\" largest-magnitude\n            // moment tokens that have a value. All lesser-magnitude moment tokens\n            // will be ignored. This option takes effect even if `trim` is set\n            // to `false`.\n            largest: null,\n\n            // maxValue\n            // Use `maxValue` to render generalized output for large duration values,\n            // e.g. `\"> 60 days\"`. `maxValue` must be a positive integer and is\n            /// applied to the greatest-magnitude moment token in the format template.\n            maxValue: null,\n\n            // minValue\n            // Use `minValue` to render generalized output for small duration values,\n            // e.g. `\"< 5 minutes\"`. `minValue` must be a positive integer and is\n            // applied to the least-magnitude moment token in the format template.\n            minValue: null,\n\n            // precision\n            // If a positive integer, number of decimal fraction digits to render.\n            // If a negative integer, number of integer place digits to truncate to 0.\n            // If `useSignificantDigits` is set to `true` and `precision` is a positive\n            // integer, sets the maximum number of significant digits used in the\n            // formatted output.\n            precision: 0,\n\n            // trunc\n            // Default behavior rounds final token value. Set to `true` to\n            // truncate final token value, which was the default behavior in\n            // version 1 of this plugin.\n            trunc: false,\n\n            // forceLength\n            // Force first moment token with a value to render at full length\n            // even when template is trimmed and first moment token has length of 1.\n            forceLength: null,\n\n            // userLocale\n            // Formatted numerical output is rendered using `toLocaleString`\n            // and the locale of the user's environment. Set this option to render\n            // numerical output using a different locale. Unit names are rendered\n            // and detected using the locale set in moment.js, which can be different\n            // from the locale of user's environment.\n            userLocale: null,\n\n            // usePlural\n            // Will automatically singularize or pluralize unit names when they\n            // appear in the text associated with each moment token. Standard and\n            // short unit labels are singularized and pluralized, based on locale.\n            // e.g. in english, \"1 second\" or \"1 sec\" would be rendered instead\n            // of \"1 seconds\" or \"1 secs\". The default pluralization function\n            // renders a plural label for a value with decimal precision.\n            // e.g. \"1.0 seconds\" is never rendered as \"1.0 second\".\n            // Label types and pluralization function are configurable in the\n            // localeData extensions.\n            usePlural: true,\n\n            // useLeftUnits\n            // The text to the right of each moment token in a format string\n            // is treated as that token's units for the purposes of trimming,\n            // singularizing, and auto-localizing.\n            // e.g. \"h [hours], m [minutes], s [seconds]\".\n            // To properly singularize or localize a format string such as\n            // \"[hours] h, [minutes] m, [seconds] s\", where the units appear\n            // to the left of each moment token, set useLeftUnits to `true`.\n            // This plugin is not tested in the context of rtl text.\n            useLeftUnits: false,\n\n            // useGrouping\n            // Enables locale-based digit grouping in the formatted output. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n            useGrouping: true,\n\n            // useSignificantDigits\n            // Treat the `precision` option as the maximum significant digits\n            // to be rendered. Precision must be a positive integer. Significant\n            // digits extend across unit types,\n            // e.g. \"6 hours 37.5 minutes\" represents 4 significant digits.\n            // Enabling this option causes token length to be ignored. See  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n            useSignificantDigits: false,\n\n            // template\n            // The template string used to format the duration. May be a function\n            // or a string. Template functions are executed with the `this` binding\n            // of the settings object so that template strings may be dynamically\n            // generated based on the duration object (accessible via `this.duration`)\n            // or any of the other settings. Leading and trailing space, comma,\n            // period, and colon characters are trimmed from the resulting string.\n            template: defaultFormatTemplate,\n\n            // useToLocaleString\n            // Set this option to `false` to ignore the `toLocaleString` feature\n            // test and force the use of the `formatNumber` fallback function\n            // included in this plugin.\n            useToLocaleString: true,\n\n            // formatNumber fallback options.\n            // When `toLocaleString` is detected and passes the feature test, the\n            // following options will have no effect: `toLocaleString` will be used\n            // for formatting and the grouping separator, decimal separator, and\n            // integer digit grouping will be determined by the user locale.\n\n            // groupingSeparator\n            // The integer digit grouping separator used when using the fallback\n            // formatNumber function.\n            groupingSeparator: \",\",\n\n            // decimalSeparator\n            // The decimal separator used when using the fallback formatNumber\n            // function.\n            decimalSeparator: \".\",\n\n            // grouping\n            // The integer digit grouping used when using the fallback formatNumber\n            // function. Must be an array. The default value of `[3]` gives the\n            // standard 3-digit thousand/million/billion digit groupings for the\n            // \"en\" locale. Setting this option to `[3, 2]` would generate the\n            // thousand/lakh/crore digit groupings used in the \"en-IN\" locale.\n            grouping: [3]\n        };\n\n        context.updateLocale('en', engLocale);\n    }\n\n    // Run feature tests for `Number#toLocaleString`.\n    toLocaleStringWorks = featureTestToLocaleString();\n    toLocaleStringRoundingWorks = toLocaleStringWorks && featureTestToLocaleStringRounding();\n\n    // Initialize duration format on the global moment instance.\n    init(moment);\n\n    // Return the init function so that duration format can be\n    // initialized on other moment instances.\n    return init;\n});\n","\nvar content = require(\"!!../../node_modules/css-loader/index.js??ref--5-1!./clock-panel.css\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../../node_modules/css-loader/index.js??ref--5-1!./clock-panel.css\", function() {\n\t\tvar newContent = require(\"!!../../node_modules/css-loader/index.js??ref--5-1!./clock-panel.css\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}","exports = module.exports = require(\"../../node_modules/css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \".clock-panel {\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n  flex-direction: column;\\n}\\n\", \"\", {\"version\":3,\"sources\":[\"/home/daniel/dev/go/src/github.com/grafana/grafana/data/plugins/clock-panel/src/css/clock-panel.css\"],\"names\":[],\"mappings\":\"AAAA;EACE,cAAc;EACd,oBAAoB;EACpB,wBAAwB;EACxB,uBAAuB;CACxB\",\"file\":\"clock-panel.css\",\"sourcesContent\":[\".clock-panel {\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n  flex-direction: column;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = require(\"./urls\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (typeof __webpack_nonce__ === 'undefined') {\n\t\treturn null;\n\t}\n\n\treturn __webpack_nonce__;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n","\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n"],"sourceRoot":""}